<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Часовой / Пиры</title>
  <link rel="icon" type="image/svg+xml"
    href='data:image/svg+xml,<svg width="16" height="16" viewBox="0 0 16 16" fill="%23914BE3" xmlns="http://www.w3.org/2000/svg"><path d="M5.667 0C5.667 0.952 6.578 1.951 8 1.951C9.422 1.951 10.333 0.952 10.333 0H12.667C12.667 1.139 12.203 2.131 11.467 2.874C13.577 4.084 15 6.362 15 8.976C15 12.855 11.866 16 8 16C4.134 16 1 12.855 1 8.976C1 6.363 2.422 4.084 4.532 2.874C3.797 2.131 3.333 1.139 3.333 0H5.667ZM8 4.293C5.423 4.293 3.333 6.389 3.333 8.976C3.333 11.562 5.423 13.659 8 13.659C10.577 13.659 12.667 11.562 12.667 8.976C12.667 6.389 10.577 4.293 8 4.293Z" /></svg>' />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <script src="login.js"></script>
  <script src="script.js"></script>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="container w-peers">
    <header>
      <div class="header-left">
        <a href="../index.html" onclick="return openUniqueTab(this.href, 'tab_index')" class="logo">Часовой
          <span>Пиры</span></a><span class="connection-status"></span>
      </div>

      <div class="controls">
        <select id="update-interval">
          <option value="manual" selected>Вручную</option>
          <option value="5">Каждые 5 минут</option>
          <option value="15">Каждые 15 минут</option>
          <option value="30">Каждые 30 минут</option>
          <option value="60">Каждый час</option>
        </select>

        <button id="update-btn">Обновить</button>
      </div>
    </header>

    <div class="main-grid">
      <div class="left-column">
        <div class="settings-panel">
          <label class="checkbox-label"><input type="checkbox" checked data-target="prp"> PRP</label>
          <label class="checkbox-label"><input type="checkbox" checked data-target="xp"> XP</label>
          <label class="checkbox-label"><input type="checkbox" checked data-target="expToNext"> XP след.</label>
          <label class="checkbox-label"><input type="checkbox" checked data-target="level"> Уровень</label>
          <label class="checkbox-label"><input type="checkbox" checked data-target="coins"> Монетки</label>
          <label class="checkbox-label"><input type="checkbox" checked data-target="projects"> Проекты</label>
          <label class="checkbox-label"><input type="checkbox" checked data-target="status"> Статус</label>
        </div>
      </div>

      <div class="center-column">
        <div class="add-participant">
          <input type="text" id="login-input" placeholder="Свой логин или логины друзей (например, watchman)" />
          <button id="add-btn">Добавить</button>
        </div>

        <div class="participants-list" id="participants-list">
          <!-- Participants will be added here -->
          <div class="placeholder-card"></div>
          <div class="placeholder-card"></div>
          <div class="placeholder-card"></div>
          <div class="placeholder-card"></div>
        </div>
      </div>

      <div class="right-column">
        <div class="updates-log" id="updates-log">
          <!-- Logs will appear here -->
        </div>
      </div>
    </div>

    <footer class="page-footer">
      <div class="footer-left">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="#7D838E" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M5.667 0C5.667 0.952 6.578 1.951 8 1.951C9.422 1.951 10.333 0.952 10.333 0H12.667C12.667 1.139 12.203 2.131 11.467 2.874C13.577 4.084 15 6.362 15 8.976C15 12.855 11.866 16 8 16C4.134 16 1 12.855 1 8.976C1 6.363 2.422 4.084 4.532 2.874C3.797 2.131 3.333 1.139 3.333 0H5.667ZM8 4.293C5.423 4.293 3.333 6.389 3.333 8.976C3.333 11.562 5.423 13.659 8 13.659C10.577 13.659 12.667 11.562 12.667 8.976C12.667 6.389 10.577 4.293 8 4.293Z" />
        </svg>
        <span class="motto"><a href="https://github.com/rafikov/watchman">Часовой</a> на гите</span>
      </div>
  </div>

  <div id="status-message"></div>

  <script>
    const participants = new Map();
    let subscriptionTimer = null;
    let countdownTimer = null;

    const loginInput = document.getElementById("login-input");
    const addBtn = document.getElementById("add-btn");
    const participantsList = document.getElementById("participants-list");
    const updatesLog = document.getElementById("updates-log");
    const updateBtn = document.getElementById("update-btn");
    const intervalSelect = document.getElementById("update-interval");
    const statusMessage = document.getElementById("status-message");

    function saveToStorage() {
      saveMapToStorage("watchman_peers", participants);
    }

    function loadFromStorage() {
      const loaded = loadMapFromStorage(
        "watchman_peers",
        participants,
        "Failed to load peers"
      );
      if (loaded) {
        renderParticipants();
      }
    }

    window.addEventListener("load", () => {
      loadFromStorage();
      checkUpdates();
      startAutoUpdate();
      checkSystemStatus();
    });

    async function fetchPeerData(token, login) {
      const basicRes = await fetch(`${BASE_URL}/participants/${login}`, {
        headers: { Authorization: `Bearer ${token}` },
      });
      if (!basicRes.ok) throw new Error(`User ${login} not found`);
      const basic = await basicRes.json();

      const pointsRes = await fetch(
        `${BASE_URL}/participants/${login}/points`,
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      );
      if (!pointsRes.ok)
        console.warn(`Failed to fetch points for ${login}`, pointsRes.status);
      const pointsData = pointsRes.ok ? await pointsRes.json() : {};

      const projRes = await fetch(
        `${BASE_URL}/participants/${login}/projects?limit=1000`,
        {
          headers: { Authorization: `Bearer ${token}` },
        }
      );
      if (!projRes.ok)
        console.warn(`Failed to fetch projects for ${login}`, projRes.status);
      const projBody = projRes.ok ? await projRes.json() : {};
      const projData = projBody.projects || [];

      let onlineStatus = "Offline";
      try {
        const workRes = await fetch(
          `${BASE_URL}/participants/${login}/workstation`,
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );
        if (workRes.ok) {
          const work = await workRes.json();
          onlineStatus = `Online (${work.clusterName} ${work.row}${work.number})`;
        } else {
          onlineStatus = basic.status || "Offline";
        }
      } catch (e) {
        onlineStatus = basic.status || "Offline";
      }

      let className = basic.className || "-";

      const coins =
        pointsData.coins !== undefined
          ? pointsData.coins
          : 0;

      const prp =
        pointsData.peerReviewPoints !== undefined
          ? pointsData.peerReviewPoints
          : 0;

      const level = basic.level || 0;
      const xp = basic.expValue || 0;
      const expToNext = basic.expToNextLevel || 0;

      const processedProjects = processProjects(projData, basic.login);

      return {
        login: basic.login,
        className,
        coins,
        prp,
        level,
        xp,
        expToNext,
        status: onlineStatus,
        projects: processedProjects,
        timestamp: Date.now(),
      };
    }

    function processProjects(projData, currentLogin) {
      if (!Array.isArray(projData)) return [];

      const getTeamSuffix = (p) => {
        if (p.teamMembers && p.teamMembers.length > 0) {
          if (p.teamMembers.length > 1) {
            const me = p.teamMembers.find((m) => m.login === currentLogin);
            if (me) {
              return me.isTeamlead ? " | Lead" : " | Team";
            }
          }
        }
        return "";
      };

      const inProgress = projData.filter((p) => p.status === "IN_PROGRESS");
      const review = projData.filter((p) => p.status === "IN_REVIEWS");
      const accepted = projData.filter((p) => p.status === "ACCEPTED");

      let result = [];

      inProgress.forEach((p) =>
        result.push({
          name: p.title,
          statusLabel: "In progress" + getTeamSuffix(p),
          colorClass: "in-progress",
          rawStatus: p.status,
        })
      );

      review.forEach((p) =>
        result.push({
          name: p.title,
          statusLabel: "Review" + getTeamSuffix(p),
          colorClass: "review",
          rawStatus: p.status,
        })
      );

      accepted.sort(
        (a, b) =>
          new Date(b.completionDateTime || 0) -
          new Date(a.completionDateTime || 0)
      );
      accepted.forEach((p) =>
        result.push({
          name: p.title,
          statusLabel: "Accepted" + getTeamSuffix(p),
          colorClass: "accepted",
          rawStatus: p.status,
        })
      );

      if (result.length === 0) {
        const others = projData.filter((p) =>
          ["REGISTERED", "ASSIGNED"].includes(p.status)
        );
        others.forEach((p) =>
          result.push({
            name: p.title,
            statusLabel: "Ready to start" + getTeamSuffix(p),
            colorClass: "ready",
            rawStatus: p.status,
          })
        );

        if (result.length === 0) {
          const failed = projData.filter((p) => p.status === "FAILED");
          failed.sort(
            (a, b) =>
              new Date(b.completionDateTime || 0) -
              new Date(a.completionDateTime || 0)
          );
          failed.slice(0, 5).forEach((p) =>
            result.push({
              name: p.title,
              statusLabel: "Failed" + getTeamSuffix(p),
              colorClass: "failed",
              rawStatus: p.status,
            })
          );
        }
      }

      return result;
    }

    async function addParticipant() {
      const login = loginInput.value.trim().toLowerCase();
      if (!login) return;

      if (participants.has(login)) {
        showStatus("User already in list", true);
        return;
      }

      addBtn.disabled = true;
      addBtn.textContent = "Загружаем";
      addBtn.classList.add("btn-loading");

      try {
        const token = await getAccessToken();
        const data = await fetchPeerData(token, login);

        participants.set(login, data);
        saveToStorage();
        renderParticipants();
        loginInput.value = "";
        showStatus(`Добавлен ${login}`);
      } catch (e) {
        console.error(e);
        showStatus(`Ошибка: ${e.message}`, true);
      } finally {
        addBtn.disabled = false;
        addBtn.textContent = "Добавить";
        addBtn.classList.remove("btn-loading");
      }
    }

    function removeParticipant(login) {
      participants.delete(login);
      saveToStorage();
      renderParticipants();
    }

    function renderParticipants() {
      participantsList.innerHTML = "";

      if (participants.size === 0) {
        renderPlaceholders(participantsList, 4);
        return;
      }

      participants.forEach((data, login) => {
        const card = document.createElement("div");
        card.className = "peer-card";

        const chipsHtml = data.projects
          .map(
            (p) => `
                <div class="chip ${p.colorClass}">
                    ${p.name}
                    <span class="status-text">${p.statusLabel}</span>
                </div>
            `
          )
          .join("");

        const isOnline = data.status.startsWith("Online");
        const statusClass = isOnline ? "в&nbsp;кампусе" : "";

        card.innerHTML = `
                <button class="delete-btn delete-btn-card" onclick="removeParticipant('${login}')">Удалить</button>
                <div class="peer-header">
                    <span class="peer-login"><a href="https://platform.21-school.ru/profile/${login}" target="_blank" style="text-decoration:none; color:inherit;">${data.login}</a></span>
                    <div class="peer-stats">
                         <span class="stat-item" data-type="coins">Мон.: <span class="stat-value">${data.coins}</span></span>
                         <span class="stat-item" data-type="prp">PRP: <span class="stat-value">${data.prp}</span></span>
                         <span class="stat-item" data-type="xp">XP: <span class="stat-value">${data.xp}</span></span>
                         <span class="stat-item" data-type="expToNext">след.: ${data.expToNext}</span>
                         <span class="stat-item" data-type="level">Уровень: <span class="stat-value">${data.level}</span></span>
                    </div>
                </div>
                <div class="peer-subheader">
                    <span class="peer-status ${statusClass} stat-item" data-type="status">${data.status}</span>
					          <span class="peer-class">${data.className}</span>
                </div>
                <div class="peer-projects stat-item" data-type="projects" title="Скролл на тачпаде или клик + стрелки &larr;&rarr;">
                    ${chipsHtml || '<span style="color:#666; font-size:12px;">No active projects</span>'}
                </div>
            `;

        participantsList.appendChild(card);
      });

      applyFilters();
    }

    function applyFilters() {
      const checkboxes = document.querySelectorAll('.settings-panel input[type="checkbox"]');
      const settings = {};
      checkboxes.forEach(cb => settings[cb.dataset.target] = cb.checked);

      document.querySelectorAll('.stat-item').forEach(el => {
        const type = el.dataset.type;
        if (settings[type] !== undefined) {
          el.style.display = settings[type] ? '' : 'none';
        }
      });
    }

    document.querySelectorAll('.settings-panel input[type="checkbox"]').forEach(cb => {
      cb.addEventListener('change', applyFilters);
    });

    async function checkUpdates() {
      if (participants.size === 0) return;

      try {
        const token = await getAccessToken();

        const promises = Array.from(participants.keys()).map(
          async (login) => {
            try {
              const newData = await fetchPeerData(token, login);
              return { login, newData };
            } catch (e) {
              console.warn(`Update failed for ${login}`, e);
              return null;
            }
          }
        );

        const results = await Promise.all(promises);
        let hasUpdates = false;
        let events = [];

        results.forEach((res) => {
          if (!res) return;
          const { login, newData } = res;
          const oldData = participants.get(login);

          const settings = {};
          document.querySelectorAll('.settings-panel input[type="checkbox"]').forEach(cb => settings[cb.dataset.target] = cb.checked);

          if (settings.xp && newData.xp !== oldData.xp) {
            const diff = newData.xp - oldData.xp;
            events.push({
              login,
              text: `XP: ${diff > 0 ? "+" : ""}${diff} (${oldData.xp
                } &rarr; ${newData.xp})`,
            });
          }

          if (settings.prp && newData.prp !== oldData.prp) {
            const diff = newData.prp - oldData.prp;
            events.push({
              login,
              text: `PRP: ${diff > 0 ? "+" : ""}${diff} (${oldData.prp
                } &rarr; ${newData.prp})`,
            });
          }

          if (settings.coins && newData.coins !== oldData.coins) {
            const diff = newData.coins - oldData.coins;
            const diffStr = diff > 0 ? `+${diff}` : `${diff}`;
            events.push({
              login,
              text: `Монетки: ${diffStr} (${oldData.coins} &rarr; ${newData.coins})`
            });
          }

          if (settings.status && newData.status !== oldData.status) {
            events.push({
              login,
              text: `Статус: ${oldData.status} &rarr; ${newData.status}`,
            });
          }

          const oldProjStr = JSON.stringify(
            oldData.projects.map((p) => p.rawStatus)
          );
          const newProjStr = JSON.stringify(
            newData.projects.map((p) => p.rawStatus)
          );

          if (settings.projects && oldProjStr !== newProjStr) {
            events.push({ login, text: `Изменения в проектах` });
          }

          if (events.length > 0) hasUpdates = true;

          participants.set(login, newData);
        });

        if (hasUpdates) {
          saveToStorage();
          renderParticipants();

          events.forEach((ev) => {
            logUpdate(ev.login, ev.text);
          });

          const creds = getStoredCredentials();
          if (creds && creds.tgToken && creds.tgId && events.length > 0) {
            const msg = `Часовой / Пиры. События:\n${events
              .map((e) => `${e.login}: ${e.text}`)
              .join("\n")}`;
            sendTelegramMessage(msg.replace(/&rarr;/g, "->"));
          }
        }
      } catch (e) {
        console.error("Polling failed", e);
      }
    }

    function logUpdate(login, text) {
      const now = new Date();
      const timeStr = `${String(now.getHours()).padStart(2, "0")}:${String(
        now.getMinutes()
      ).padStart(2, "0")}`;

      const entry = document.createElement("div");
      entry.className = "log-entry";
      entry.innerHTML = `
            <div class="log-time">${timeStr}</div>
            <div class="log-content">
                <span class="log-header">${login}</span>
                <span class="log-details">${text}</span>
            </div>
        `;

      updatesLog.prepend(entry);
    }

    function startAutoUpdate() {
      if (subscriptionTimer) clearInterval(subscriptionTimer);
      if (countdownTimer) clearInterval(countdownTimer);

      const val = intervalSelect.value;
      if (val === "manual") {
        updateBtn.textContent = "Обновить";
        return;
      }

      const intervalSec = parseInt(val) * 60;
      countdownTimer = startCountdownTimer(intervalSec, (remaining) => {
        updateBtn.textContent = `Обновить (${formatDurationHMS(remaining)})`;
        if (remaining <= 0) {
          checkUpdates();
          checkSystemStatus();
          startAutoUpdate();
        }
      }, countdownTimer);
    }

    function updateDropdownText(seconds) {
      const selectedOption = intervalSelect.options[intervalSelect.selectedIndex];
      const baseText = getBaseOptionText(intervalSelect.value);
      if (intervalSelect.value === "manual") {
        selectedOption.text = baseText;
      } else {
        selectedOption.text = `${baseText} (${formatDurationHMS(seconds)})`;
      }
    }

    function getBaseOptionText(value) {
      switch (value) {
        case "manual": return "Вручную";
        case "5": return "Каждые 5 минут";
        case "15": return "Каждые 15 минут";
        case "30": return "Каждые 30 минут";
        case "60": return "Каждый час";
        default: return "Интервал";
      }
    }

    function resetDropdownText() {
      Array.from(intervalSelect.options).forEach(opt => {
        opt.text = getBaseOptionText(opt.value);
      });
    }

    intervalSelect.addEventListener("change", () => {
      resetDropdownText();
      startAutoUpdate();
      notifySubscription("Пиры", intervalSelect.value);
    });

    const showStatus = createStatusHandler(statusMessage);

    addBtn.addEventListener("click", addParticipant);
    updateBtn.addEventListener("click", async () => {
      updateBtn.classList.add("updating");
      try {
        await checkUpdates();
        await checkSystemStatus();
      } finally {
        updateBtn.classList.remove("updating");
      }
      if (intervalSelect.value !== "manual") {
        startAutoUpdate();
      }
    });
    loginInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") addParticipant();
    });

    window.participants = participants;
    window.saveToStorage = saveToStorage;
    window.logUpdate = logUpdate;
    window.renderParticipants = renderParticipants;
    window.sendTelegramMessage = sendTelegramMessage;
    window.showStatus = showStatus;
  </script>

  <!--<script src="debug.js"></script>-->
</body>

</html>