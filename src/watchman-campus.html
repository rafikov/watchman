<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Вахтёр / Кампус</title>
  <link rel="icon" type="image/svg+xml"
    href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 18 15' fill='%23FFC540'><path d='M12.5 0C15.538 0 18 2.462 18 5.5V15H5v-3h10V9H5V6h10v-.5C15 4.119 13.881 3 12.5 3H5V0h7.5zM0 3h3v3H0zm0 6h3v3H0z'/></svg>" />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <script src="login.js"></script>
  <script src="maps.js"></script>
  <script src="script.js"></script>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="container w-campus">
    <header>
      <a href="../index.html" onclick="return openUniqueTab(this.href, 'tab_index')" class="logo">Вахтёр
        <span>Кампус</span></a>

      <div class="controls">
        <div class="controls-group">
          <select id="event-select">
            <option value="all">Все пиры</option>
            <option value="login">Выбранные пиры (0)</option>
            <option value="add">Выбрать пира</option>
          </select>
        </div>

        <div class="controls-group">
          <select id="update-interval">
            <option value="5">Каждые 5 минут</option>
            <option value="15">Каждые 15 минут</option>
            <option value="30">Каждые 30 минут</option>
            <option value="60">Каждый час</option>
          </select>

          <label class="checkbox-label">
            <input type="checkbox" id="sound-enabled" />
            Звук
          </label>

          <label class="checkbox-label">
            <input type="checkbox" id="telegram-enabled" />
            Телеграм
          </label>

          <button id="subscribe-btn">Подписаться</button>
        </div>
      </div>
    </header>

    <div class="modal-selected" id="modal-selected" style="display: none">
      <div class="select-peer">
        <button class="close-modal" id="close-modal">&times;</button>
        <div class="add-participant">
          <input type="text" id="login-input" placeholder="Имя пира (например, watchman)" />
          <button id="add-btn">Добавить</button>
        </div>

        <div class="participants-list" id="participants-list">
          <!-- Participants will be added here -->
        </div>
      </div>
    </div>

    <div class="map-container">
      <div class="map-view" id="map-view">
        <!-- Clusters and seats will be rendered here -->
        <div id="map-loading" class="loading-overlay" style="display: none">
          Загрузка карты...
        </div>

        <div class="preload">
          <div class="cluster_cont">
            <div class="cluster-section">
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
            </div>

            <div class="cluster-section">
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="sidebar" id="events-sidebar">
        <div class="sidebar-toggle" id="sidebar-toggle">
          <span>◀</span>
        </div>
        <div class="event-header">
          <h3>События</h3>
        </div>
        <div class="log-container" id="events-log">
          <!-- Logs here -->
        </div>
      </div>
    </div>

    <footer class="page-footer">
      <div class="footer-left">
        <svg width="18" height="15" viewBox="0 0 18 15" fill="#7D838E">
          <path
            d="M12.5 0C15.538 0 18 2.462 18 5.5V15H5v-3h10V9H5V6h10v-.5C15 4.119 13.881 3 12.5 3H5V0h7.5zM0 3h3v3H0zm0 6h3v3H0z" />
        </svg>
        <span class="motto"><a href="https://github.com/rafikov/watchman">Вахтёр</a> сидит на гите</span>
      </div>

      <div class="footer-right">
        <select id="campus-select">
          <option value="5a23bec9-f989-485d-935b-3f0dc61c4812">
            Нижний Новгород
          </option>
          <option value="6bfe3c56-0211-4fe1-9e59-51616caac4dd">Москва</option>
          <option value="7c293c9c-f28c-4b10-be29-560e4b000a34">Казань</option>
          <option value="46e7d965-21e9-4936-bea9-f5ea0d1fddf2">
            Новосибирск
          </option>
        </select>
      </div>
    </footer>
  </div>

  <div id="seat-tooltip" class="seat-tooltip">
    <h3 id="tt-login">Login</h3>
    <div class="meta">
      <span id="tt-location">Location</span>
    </div>
    <div class="meta">
      <span id="tt-classname">Class</span>
      <span id="tt-level">Level</span>
    </div>
    <div class="project">
      <span id="tt-project">Project</span>
      <span id="tt-status" class="status-badge">Status</span>
    </div>
  </div>

  <div id="status-message"></div>

  <script>
    let currentCampusId = "5a23bec9-f989-485d-935b-3f0dc61c4812";

    var clusters = [];
    var mapData = new Map();
    var hostState = new Map();
    var isSubscribed = false;
    var pollTimer = null;
    var countdownTimer = null;
    var selectedPeers = new Set();

    const mapView = document.getElementById("map-view");
    const mapLoading = document.getElementById("map-loading");
    const seatTooltip = document.getElementById("seat-tooltip");
    const eventsSidebar = document.getElementById("events-sidebar");
    const sidebarToggle = document.getElementById("sidebar-toggle");
    const eventsLog = document.getElementById("events-log");
    const subscribeBtn = document.getElementById("subscribe-btn");
    const intervalSelect = document.getElementById("update-interval");
    const eventSelect = document.getElementById("event-select");
    const soundCheckbox = document.getElementById("sound-enabled");
    const telegramCheckbox = document.getElementById("telegram-enabled");
    const campusSelect = document.getElementById("campus-select");

    const modalSelected = document.getElementById("modal-selected");
    const closeModalBtn = document.getElementById("close-modal");
    const addPeerBtn = document.getElementById("add-btn");
    const peerInput = document.getElementById("login-input");
    const participantsList = document.getElementById("participants-list");

    eventsSidebar.style.display = "none";

    window.addEventListener("load", () => {
      if (typeof TG_CONFIG === "undefined" || !TG_CONFIG.botToken) {
        if (telegramCheckbox) {
          telegramCheckbox.disabled = true;
          telegramCheckbox.title = "Configure bot in login.js";
        }
      }
    });

    function loadSelectedPeers() {
      try {
        const stored = localStorage.getItem("watchman_campus_peers");
        if (stored) {
          const list = JSON.parse(stored);
          list.forEach((p) => selectedPeers.add(p));
          updateSelectOption();
          renderPeerList();
        }
      } catch (e) {
        console.error("Failed to load peers", e);
      }
    }

    function saveSelectedPeers() {
      localStorage.setItem(
        "watchman_campus_peers",
        JSON.stringify(Array.from(selectedPeers))
      );
      updateSelectOption();
      renderPeerList();
    }

    function updateSelectOption() {
      const option = eventSelect.querySelector('option[value="login"]');
      if (option) {
        option.textContent = `Выбранные пиры (${selectedPeers.size})`;
      }
    }

    function addPeer() {
      const login = peerInput.value.trim().toLowerCase();
      if (!login) return;

      if (selectedPeers.has(login)) {
        return;
      }

      selectedPeers.add(login);
      saveSelectedPeers();
      peerInput.value = "";
      renderPeerList();
      renderMap();
    }

    function removePeer(login) {
      selectedPeers.delete(login);
      saveSelectedPeers();
      renderPeerList();
      renderMap();
    }

    function renderPeerList() {
      participantsList.innerHTML = "";
      if (selectedPeers.size === 0) {
        participantsList.innerHTML =
          '<div style="color: #8b949e; padding: 20px; text-align: center;">Список пуст</div>';
        return;
      }

      selectedPeers.forEach((login) => {
        const div = document.createElement("div");
        div.className = "participant-card";
        div.innerHTML = `
                <span class="participant-name">${login}</span>
                <button class="delete-btn" onclick="removePeer('${login}')">Удалить</button>
            `;
        participantsList.appendChild(div);
      });
    }

    closeModalBtn.addEventListener("click", () => {
      modalSelected.style.display = "none";
    });

    addPeerBtn.addEventListener("click", addPeer);

    eventSelect.addEventListener("change", () => {
      const value = eventSelect.value;
      if (value === "add") {
        modalSelected.style.display = "flex";
        eventSelect.value = "login";
        checkUpdates();
      } else if (value === "login") {
        if (selectedPeers.size === 0) {
          modalSelected.style.display = "flex";
        }
        checkUpdates();
      } else {
        checkUpdates();
      }
    });

    loadSelectedPeers();

    peerInput.addEventListener("keypress", (e) => {
      if (e.key === "Enter") addPeer();
    });

    modalSelected.addEventListener("click", (e) => {
      if (e.target === modalSelected) {
        modalSelected.style.display = "none";
      }
    });

    async function fetchCampuses() {
      try {
        const token = await getAccessToken();
        const res = await fetch(`${BASE_URL}/campuses`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        if (res.ok) {
          const data = await res.json();
          populateCampusSelect(data.campuses || []);
        }
      } catch (e) {
        console.error("Failed to fetch campuses", e);
      }
    }

    function populateCampusSelect(campusesList) {
      const existingValues = new Set(
        Array.from(campusSelect.options).map((o) => o.value)
      );

      campusesList.forEach((c) => {
        if (!existingValues.has(c.id) && !IGNORED_CAMPUSES.has(c.id)) {
          const opt = document.createElement("option");
          opt.value = c.id;
          let name = c.fullName || c.name;
          if (name.startsWith("Школа 21, ")) {
            name = name.substring(10);
          }
          opt.textContent = name;
          campusSelect.appendChild(opt);
        }
      });
    }

    campusSelect.addEventListener("change", () => {
      const val = campusSelect.value;
      if (!val) return;

      currentCampusId = val;

      clusters = [];
      mapData.clear();
      hostState.clear();

      const loading = mapLoading;
      const preload = document.querySelector(".preload");

      mapView.innerHTML = "";
      mapView.appendChild(loading);

      if (preload) {
        preload.style.display = "flex";
        mapView.appendChild(preload);
      }

      loadFullMap();
    });

    eventSelect.addEventListener("change", () => {
      const val = eventSelect.value;

      if (val === "add") {
        modalSelected.style.display = "flex";
        eventSelect.value = "login";
      } else if (val === "login") {
        if (selectedPeers.size === 0) {
          modalSelected.style.display = "flex";
        }
      }

      renderMap();
    });

    loadSelectedPeers();

    sidebarToggle.addEventListener("click", () => {
      eventsSidebar.classList.toggle("visible");
      sidebarToggle.innerHTML = eventsSidebar.classList.contains("visible")
        ? "▶"
        : "◀";
    });

    let activeTooltip = null;
    let activeSeatElement = null;

    function hideTooltip() {
      seatTooltip.classList.remove("active");
      if (activeSeatElement) {
        activeSeatElement.classList.remove("selected");
        activeSeatElement = null;
      }
    }

    window.addEventListener("scroll", hideTooltip, true);
    mapView.addEventListener("scroll", hideTooltip);

    const UserCache = {
      get: (login) => {
        try {
          const data = localStorage.getItem(`watchman_user_${login}`);
          if (!data) return null;
          const parsed = JSON.parse(data);
          if (Date.now() - parsed.timestamp > 24 * 60 * 60 * 1000)
            return null;
          return parsed;
        } catch (e) {
          return null;
        }
      },
      set: (login, data) => {
        try {
          localStorage.setItem(
            `watchman_user_${login}`,
            JSON.stringify({
              ...data,
              timestamp: Date.now(),
            })
          );
        } catch (e) {
          console.warn("Cache full or error", e);
        }
      },
    };

    document.addEventListener("click", (e) => {
      if (
        !seatTooltip.contains(e.target) &&
        !e.target.classList.contains("seat")
      ) {
        hideTooltip();
      }
    });



    async function fetchClusters(token) {
      let retries = 3;
      while (retries > 0) {
        try {
          const authToken = token || (await getAccessToken());
          const response = await fetch(
            `${BASE_URL}/campuses/${currentCampusId}/clusters`,
            {
              headers: { Authorization: `Bearer ${authToken}` },
            }
          );

          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

          const data = await response.json();
          if (data && data.clusters) {
            clusters = data.clusters.sort((a, b) =>
              b.name.localeCompare(a.name)
            );
          } else {
            console.warn("Unexpected clusters format:", data);
            clusters = [];
          }
          return clusters;
        } catch (e) {
          console.warn(`Retry fetchClusters (${retries} left)`, e);
          retries--;
          if (retries === 0) {
            console.error("Error fetching clusters:", e);
            showStatus("Error fetching clusters");
            return [];
          }
          await new Promise((r) =>
            setTimeout(r, 2000 * Math.pow(2, 3 - retries))
          );
        }
      }
    }

    async function fetchClusterMap(clusterId, token) {
      const authToken = token || (await getAccessToken());
      const response = await fetch(`${BASE_URL}/clusters/${clusterId}/map`, {
        headers: { Authorization: `Bearer ${authToken}` },
      });

      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);

      const data = await response.json();
      return data.clusterMap || [];
    }

    async function loadFullMap(isRefresh = false) {
      if (!isRefresh) {
        mapLoading.style.display = "flex";
        const preload = document.querySelector(".preload");
        if (preload) preload.style.display = "flex";
      }

      try {
        const token = await getAccessToken();

        if (clusters.length === 0) {
          await fetchClusters(token);
        }

        const promises = clusters.map(async (cluster) => {
          await new Promise((r) => setTimeout(r, Math.random() * 500));

          let retries = 3;
          while (retries > 0) {
            try {
              const hosts = await fetchClusterMap(cluster.id, token);
              mapData.set(cluster.id, hosts);

              hosts.forEach((host) => {
                const seatId = `${cluster.id}-${host.row}-${host.number}`;

                if (host.login) {
                  hostState.set(seatId, {
                    user: host.login,
                    seatId: seatId,
                    location: `${cluster.name} ${host.row}-${host.number}`,
                  });
                } else {
                  if (hostState.has(seatId)) {
                    hostState.delete(seatId);
                  }
                }
              });
              break;
            } catch (e) {
              console.warn(
                `Retry map fetch for ${cluster.name} (${retries} left)`,
                e
              );
              retries--;
              if (retries === 0)
                console.error(`Failed to fetch map for ${cluster.name}`);
              await new Promise((r) =>
                setTimeout(r, 2000 * Math.pow(2, 3 - retries))
              );
            }
          }
        });

        await Promise.all(promises);
        renderMap();
      } catch (e) {
        console.error("Error in loadFullMap:", e);
        showStatus("Ошибка при закгрузке карты");
      } finally {
        mapLoading.style.display = "none";
      }
    }

    async function preloadTopParticipants() {
      const seats = Array.from(
        document.querySelectorAll(".seat.occupied")
      ).slice(0, 10);
      if (seats.length === 0) return;

      try {
        const token = await getAccessToken();
        seats.forEach(async (seat) => {
          const login = seat.dataset.login;
          if (login && !UserCache.get(login)) {
            try {
              const details = await fetchUserDetails(login, token);
              UserCache.set(login, details);
            } catch (e) {
              console.error("Preload failed for", login);
            }
          }
        });
      } catch (e) {
        console.error("Preload token error");
      }
    }

    function renderMap() {
      const loading = mapLoading;
      const preload = document.querySelector(".preload");

      mapView.innerHTML = "";
      mapView.appendChild(loading);
      if (preload) {
        preload.style.display = "none";
        mapView.appendChild(preload);
      }

      if (clusters.length === 0) {
        const msg = document.createElement("div");
        msg.className = "message-loaded";
        msg.style.position = "relative";
        msg.style.background = "transparent";
        msg.textContent = "Нет кластеров в этом кампусе";
        mapView.appendChild(msg);
        return;
      }

      const template = CAMPUS_TEMPLATES[currentCampusId];
      let itemsToRender = [];
      const renderedClusterIds = new Set();

      if (template) {
        template.forEach((item) => {
          if (item.type === "html") {
            itemsToRender.push(item);
          } else if (item.type === "cluster") {
            const cluster = clusters.find(
              (c) =>
                (item.id && c.id === item.id) ||
                (item.name && c.name === item.name)
            );
            if (cluster) {
              itemsToRender.push({ ...item, cluster });
              renderedClusterIds.add(cluster.id);
            }
          }
        });
      }

      clusters.forEach((cluster) => {
        if (!renderedClusterIds.has(cluster.id)) {
          itemsToRender.push({ type: "cluster", cluster, align: "left" });
        }
      });

      let currentPair = [];

      itemsToRender.forEach((item) => {
        if (item.type === "html") {
          if (currentPair.length > 0) {
            const cont = document.createElement("div");
            cont.className = "cluster_cont";
            currentPair.forEach((el) => cont.appendChild(el));
            mapView.appendChild(cont);
            currentPair = [];
          }

          const div = document.createElement("div");
          div.innerHTML = item.content;
          mapView.appendChild(div);
          return;
        }

        const cluster = item.cluster;
        const hosts = mapData.get(cluster.id) || [];
        if (hosts.length === 0) return;

        const rowCounts = new Map();
        let isWide = false;
        hosts.forEach((h) =>
          rowCounts.set(h.row, (rowCounts.get(h.row) || 0) + 1)
        );
        for (let count of rowCounts.values()) {
          if (count > 10) {
            isWide = true;
            break;
          }
        }

        const section = document.createElement("div");
        section.className = "cluster-section";

        const title = document.createElement("h3");
        title.className = "cluster-title";
        title.textContent = cluster.name;
        section.appendChild(title);

        const rows = new Map();
        hosts.forEach((host) => {
          const r = host.row;
          if (!rows.has(r)) rows.set(r, []);
          rows.get(r).push(host);
        });

        const sortedRows = Array.from(rows.keys()).sort((a, b) => a - b);

        sortedRows.forEach((r) => {
          const rowDiv = document.createElement("div");
          rowDiv.className = "seat-row";
          if (item.align === "right") {
            rowDiv.classList.add("right");
          }

          const rowHosts = rows.get(r).sort((a, b) => a.number - b.number);

          rowHosts.forEach((host) => {
            const seat = document.createElement("div");
            seat.className = "seat";
            seat.textContent = host.number;

            const location = `${cluster.name} ${host.row}-${host.number}`;
            seat.dataset.location = location;

            if (host.isLocked || host.status === "blocked") {
              seat.classList.add("blocked");
              seat.title = "Blocked";
            }

            if (host.login) {
              seat.classList.add("occupied");
              seat.dataset.login = host.login;
              seat.title = host.login;

              if (selectedPeers.has(host.login.toLowerCase())) {
                seat.classList.add("watched");
              }

              seat.addEventListener("click", (e) =>
                showTooltip(e, host, location)
              );
            }

            rowDiv.appendChild(seat);
          });

          section.appendChild(rowDiv);
        });

        if (isWide) {
          if (currentPair.length > 0) {
            const cont = document.createElement("div");
            cont.className = "cluster_cont";
            currentPair.forEach((el) => cont.appendChild(el));
            mapView.appendChild(cont);
            currentPair = [];
          }
          const cont = document.createElement("div");
          cont.className = "cluster_cont";
          cont.appendChild(section);
          mapView.appendChild(cont);
        } else {
          currentPair.push(section);

          if (currentPair.length === 2) {
            const cont = document.createElement("div");
            cont.className = "cluster_cont";
            currentPair.forEach((el) => cont.appendChild(el));
            mapView.appendChild(cont);
            currentPair = [];
          }
        }
      });

      if (currentPair.length > 0) {
        const cont = document.createElement("div");
        cont.className = "cluster_cont";
        currentPair.forEach((el) => cont.appendChild(el));
        mapView.appendChild(cont);
      }

      preloadTopParticipants();
    }

    async function showTooltip(e, host, location) {
      e.stopPropagation();

      if (activeSeatElement) {
        activeSeatElement.classList.remove("selected");
      }
      activeSeatElement = e.target;
      activeSeatElement.classList.add("selected");

      const rect = e.target.getBoundingClientRect();

      seatTooltip.style.top = `${rect.top + window.scrollY - 150}px`;
      seatTooltip.style.left = `${rect.left + window.scrollX - 120}px`;
      seatTooltip.classList.add("active");

      document.getElementById("tt-location").textContent = location;

      if (host.login) {
        document.getElementById("tt-login").innerHTML =
          '<a href="https://platform.21-school.ru/profile/' +
          host.login +
          '" target="_blank">' +
          host.login +
          "</a>";

        if (window.handleDebugTooltip && window.handleDebugTooltip(host.login)) {
          return;
        }

        const cached = UserCache.get(host.login);
        if (cached) {
          updateTooltipUI(cached);
          return;
        }

        document.getElementById("tt-level").textContent = "Загружаем...";
        document.getElementById("tt-classname").textContent = "...";
        document.getElementById("tt-project").textContent = "Загружаем...";
        document.getElementById("tt-status").textContent = "...";
        document.getElementById("tt-status").style.background = "#eee";

        try {
          const token = await getAccessToken();
          const details = await fetchUserDetails(host.login, token);

          UserCache.set(host.login, details);
          updateTooltipUI(details);
        } catch (err) {
          console.error(err);
        }
      }
    }

    function updateTooltipUI(details) {
      document.getElementById("tt-level").textContent =
        "Уровень: " + details.level;
      document.getElementById("tt-classname").textContent = details.className;
      document.getElementById("tt-project").textContent = details.project;
      document.getElementById("tt-status").textContent = details.status;
      document.getElementById("tt-status").style.background =
        details.statusColor;
    }

    async function fetchUserDetails(login, token) {
      let level = "-";
      let className = "-";
      let project = "Нет проекта";
      let status = "-";
      let statusColor = "#eee";

      try {
        const basicRes = await fetch(`${BASE_URL}/participants/${login}`, {
          headers: { Authorization: `Bearer ${token}` },
        });

        if (basicRes.ok) {
          const basic = await basicRes.json();
          if (basic.level !== undefined && basic.level !== null)
            level = basic.level;
          if (basic.className) className = basic.className;
          else if (basic.pool_month && basic.pool_year)
            className = `${basic.pool_month} ${basic.pool_year}`;
          if (basic.status) status = basic.status;
        }

        const projRes = await fetch(
          `${BASE_URL}/participants/${login}/projects?limit=1000`,
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );

        if (projRes.ok) {
          const projBody = await projRes.json();
          const projData = projBody.projects || [];

          const getPriority = (status) => {
            const s = status ? status.toUpperCase() : "";
            if (
              [
                "IN_REVIEWS",
                "REVIEWING",
                "WAITING_FOR_PEER_REVIEW",
                "PEER_REVIEW",
                "CHECKING",
                "WAITING_FOR_CORRECTION",
              ].includes(s)
            )
              return 1;
            if (["IN_PROGRESS", "REGISTERED", "ASSIGNED"].includes(s))
              return 2;
            if (s === "ACCEPTED") return 3;
            if (s === "FAILED") return 4;
            return 5;
          };

          const getDate = (p) => {
            return new Date(
              p.updatedDateTime ||
              p.createdDateTime ||
              p.completionDateTime ||
              0
            ).getTime();
          };

          projData.sort((a, b) => {
            const prioA = getPriority(a.status);
            const prioB = getPriority(b.status);
            if (prioA !== prioB) return prioA - prioB;
            return getDate(b) - getDate(a);
          });

          if (projData.length > 0) {
            const p = projData[0];
            project = p.title;

            if (p.status) {
              status = p.status
                .toLowerCase()
                .split("_")
                .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                .join(" ");
            } else {
              status = "Unknown";
            }

            const prio = getPriority(p.status);
            if (prio <= 2) statusColor = "#fff3cd";
            else if (prio === 3) statusColor = "#d1e7dd";
            else statusColor = "#f8d7da";
          }
        }

        return { level, className, project, status, statusColor };
      } catch (e) {
        console.error("Fetch Details Critical Fail", e);
        return { level, className, project, status, statusColor };
      }
    }

    fetchCampuses();
    loadFullMap();

    function showStatus(msg) {
      const el = document.getElementById("status-message");
      el.textContent = msg;
      el.className = "show";
      setTimeout(() => (el.className = ""), 3000);
    }

    subscribeBtn.addEventListener("click", () => {
      if (!isSubscribed) {
        isSubscribed = true;
        subscribeBtn.textContent = "Отписаться";
        subscribeBtn.classList.add("active");

        if (telegramCheckbox.checked) {
          sendTelegramMessage(
            "Включена подписка на события Вахтёр / Кампус"
          );
        }

        const minutes = parseInt(intervalSelect.value);
        startPolling(minutes);
      } else {
        isSubscribed = false;
        subscribeBtn.textContent = "Подписаться";
        subscribeBtn.classList.remove("active");
        stopPolling();
      }
    });

    function startPolling(minutes) {
      checkUpdates();

      pollTimer = setInterval(checkUpdates, minutes * 60 * 1000);

      let seconds = minutes * 60;
      updateCountdown(seconds);
      countdownTimer = setInterval(() => {
        seconds--;
        if (seconds <= 0) seconds = minutes * 60;
        updateCountdown(seconds);
      }, 1000);
    }

    function stopPolling() {
      clearInterval(pollTimer);
      clearInterval(countdownTimer);
      subscribeBtn.textContent = "Подписаться";
    }

    function updateCountdown(seconds) {
      const m = Math.floor(seconds / 60);
      const s = seconds % 60;
      subscribeBtn.textContent = `${m}:${s.toString().padStart(2, "0")}`;
    }

    async function checkUpdates() {
      console.log("Checking for updates...");
      const oldState = new Map(hostState);

      await loadFullMap(true);

      const updates = [];
      const now = new Date();
      const timeStr = `${String(now.getHours()).padStart(2, "0")}:${String(
        now.getMinutes()
      ).padStart(2, "0")}`;
      const filterMode = eventSelect.value;

      function shouldTrack(user) {
        if (!user) return false;
        if (filterMode === "login") {
          return selectedPeers.has(user.toLowerCase());
        }
        return true;
      }

      hostState.forEach((data, key) => {
        if (!oldState.has(key)) {
          if (shouldTrack(data.user)) {
            updates.push({
              type: "login",
              location: data.location,
              user: data.user,
              time: timeStr,
            });
          }
        } else if (oldState.get(key).user !== data.user) {
          if (shouldTrack(data.user)) {
            updates.push({
              type: "change",
              location: data.location,
              user: data.user,
              time: timeStr,
            });
          }
        }
      });

      oldState.forEach((data, key) => {
        if (!hostState.has(key)) {
          if (shouldTrack(data.user)) {
            updates.push({
              type: "logout",
              location: data.location,
              user: data.user,
              time: timeStr,
            });
          }
        }
      });

      if (updates.length > 0) {
        updates.forEach((update) => logUpdate(update));
        if (soundCheckbox.checked) {
          playSound();
        }

        if (telegramCheckbox.checked) {
          const msg = `Вахтёр / Кампус. События:\n${updates
            .map((u) => {
              let text = "";
              if (u.type === "login") text = `Login: ${u.user} at ${u.location}`;
              else if (u.type === "logout") text = `Logout: ${u.user} from ${u.location}`;
              else if (u.type === "change") text = `Changed: ${u.user} at ${u.location}`;
              return `${u.time} ${text}`;
            })
            .join("\n")}`;
          sendTelegramMessage(msg);
        }
      }
    }

    function logUpdate(update) {
      const entry = document.createElement("div");
      entry.className = "log-entry";
      let msg = "";
      if (update.type === "login") {
        msg = `Login: ${update.user} at ${update.location}`;
      } else if (update.type === "logout") {
        msg = `Logout: ${update.user} from ${update.location}`;
      } else if (update.type === "change") {
        msg = `Changed: ${update.user} at ${update.location}`;
      }

      entry.innerHTML = `<div class="log-time">${update.time}</div><div class="log-msg">${msg}</div>`;
      eventsLog.insertBefore(entry, eventsLog.firstChild);

      if (eventsLog.children.length > 0) {
        eventsSidebar.style.display = "flex";
      }
    }

    const playSound = createSoundPlayer((e) => console.error(e));

    soundCheckbox.addEventListener("change", () => {
      if (soundCheckbox.checked) {
        playSound();
      }
    });

    telegramCheckbox.addEventListener("change", async () => {
      if (telegramCheckbox.checked) {
        if (!TG_CONFIG.botToken || !TG_CONFIG.userId) {
          telegramCheckbox.checked = false;
          showStatus("Настройте бота в login.js", true);
          return;
        }

        try {
          telegramCheckbox.disabled = true;
          const botName = await verifyTelegramBot();
          showStatus(`Подключен бот: @${botName}`);
        } catch (error) {
          telegramCheckbox.checked = false;
          showStatus(`Ошибка Телеграм: ${error.message}`, true);
        } finally {
          telegramCheckbox.disabled = false;
        }
      }
    });

    window.clusters = clusters;
    window.mapData = mapData;
    window.hostState = hostState;
    window.selectedPeers = selectedPeers;
    window.logUpdate = logUpdate;
    window.playSound = playSound;
    window.showStatus = showStatus;
  </script>

  <!--<script src="debug.js"></script>-->
</body>

</html>