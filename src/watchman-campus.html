<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>–ß–∞—Å–æ–≤–æ–π / –ö–∞–º–ø—É—Å</title>
  <link rel="icon" type="image/svg+xml"
    href='data:image/svg+xml,<svg width="16" height="16" viewBox="0 0 16 16" fill="%23FFC540" xmlns="http://www.w3.org/2000/svg"><path d="M5.667 0C5.667 0.952 6.578 1.951 8 1.951C9.422 1.951 10.333 0.952 10.333 0H12.667C12.667 1.139 12.203 2.131 11.467 2.874C13.577 4.084 15 6.362 15 8.976C15 12.855 11.866 16 8 16C4.134 16 1 12.855 1 8.976C1 6.363 2.422 4.084 4.532 2.874C3.797 2.131 3.333 1.139 3.333 0H5.667ZM8 4.293C5.423 4.293 3.333 6.389 3.333 8.976C3.333 11.562 5.423 13.659 8 13.659C10.577 13.659 12.667 11.562 12.667 8.976C12.667 6.389 10.577 4.293 8 4.293Z" /></svg>' />
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Raleway:wght@400;500;600;700&display=swap" rel="stylesheet" />
  <script src="login.js"></script>
  <script src="maps.js"></script>
  <script src="script.js"></script>
  <link rel="stylesheet" href="style.css" />
</head>

<body>
  <div class="container w-campus">
    <header>
      <div class="header-left">
        <a href="../index.html" onclick="return openUniqueTab(this.href, 'tab_index')" class="logo">–ß–∞—Å–æ–≤–æ–π
          <span>–ö–∞–º–ø—É—Å</span></a><span class="connection-status"></span>
      </div>

      <div class="controls">

        <div class="controls-group">
          <select id="update-interval">
            <option value="manual" selected>–í—Ä—É—á–Ω—É—é</option>
            <option value="5">–ö–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç</option>
            <option value="15">–ö–∞–∂–¥—ã–µ 15 –º–∏–Ω—É—Ç</option>
            <option value="30">–ö–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç</option>
            <option value="60">–ö–∞–∂–¥—ã–π —á–∞—Å</option>
          </select>

          <button id="update-btn">–û–±–Ω–æ–≤–∏—Ç—å</button>
        </div>
      </div>
    </header>

    <div class="map-container">
      <div class="map-view" id="map-view">
        <!-- Clusters and seats will be rendered here -->
        <div id="map-loading" class="loading-overlay" style="display: none">
          –ó–∞–≥—Ä—É–∑–∫–∞ –∫–∞—Ä—Ç—ã...
        </div>

        <div class="preload">
          <div class="cluster_cont">
            <div class="cluster-section">
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
            </div>

            <div class="cluster-section">
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
              <div class="seat-row right">
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
                <div class="seat"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="sidebar" id="events-sidebar">
        <div class="sidebar-toggle" id="sidebar-toggle">
          <span>‚óÄ</span>
        </div>
        <div class="event-header">
          <h3>–°–æ–±—ã—Ç–∏—è</h3>
        </div>
        <div class="log-container" id="events-log">
          <!-- Logs here -->
        </div>
      </div>
    </div>

    <footer class="page-footer">
      <div class="footer-left">
        <svg width="16" height="16" viewBox="0 0 16 16" fill="#7D838E" xmlns="http://www.w3.org/2000/svg">
          <path
            d="M5.667 0C5.667 0.952 6.578 1.951 8 1.951C9.422 1.951 10.333 0.952 10.333 0H12.667C12.667 1.139 12.203 2.131 11.467 2.874C13.577 4.084 15 6.362 15 8.976C15 12.855 11.866 16 8 16C4.134 16 1 12.855 1 8.976C1 6.363 2.422 4.084 4.532 2.874C3.797 2.131 3.333 1.139 3.333 0H5.667ZM8 4.293C5.423 4.293 3.333 6.389 3.333 8.976C3.333 11.562 5.423 13.659 8 13.659C10.577 13.659 12.667 11.562 12.667 8.976C12.667 6.389 10.577 4.293 8 4.293Z" />
        </svg>
        <span class="motto"><a href="https://github.com/rafikov/watchman">–ß–∞—Å–æ–≤–æ–π</a> –Ω–∞ –≥–∏—Ç–µ</span>
      </div>

      <div class="footer-right">
        <select id="campus-select">
          <option value="5a23bec9-f989-485d-935b-3f0dc61c4812">
            –ù–∏–∂–Ω–∏–π –ù–æ–≤–≥–æ—Ä–æ–¥
          </option>
          <option value="6bfe3c56-0211-4fe1-9e59-51616caac4dd">–ú–æ—Å–∫–≤–∞</option>
          <option value="7c293c9c-f28c-4b10-be29-560e4b000a34">–ö–∞–∑–∞–Ω—å</option>
          <option value="46e7d965-21e9-4936-bea9-f5ea0d1fddf2">
            –ù–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫
          </option>
        </select>
      </div>
    </footer>
  </div>

  <div id="seat-tooltip" class="seat-tooltip">
    <h3 id="tt-login">Login</h3>
    <div class="meta">
      <span id="tt-location">Location</span>
    </div>
    <div class="meta">
      <span id="tt-classname">Class</span>
      <span id="tt-level">Level</span>
    </div>
    <div class="project">
      <span id="tt-project">Project</span>
      <span id="tt-status" class="status-badge">Status</span>
    </div>
  </div>

  <div id="status-message"></div>

  <script>
    let currentCampusId = "5a23bec9-f989-485d-935b-3f0dc61c4812";

    var clusters = [];
    var mapData = new Map();
    var hostState = new Map();
    var pollTimer = null;
    var countdownTimer = null;

    const mapView = document.getElementById("map-view");
    const mapLoading = document.getElementById("map-loading");
    const seatTooltip = document.getElementById("seat-tooltip");
    const eventsSidebar = document.getElementById("events-sidebar");
    const sidebarToggle = document.getElementById("sidebar-toggle");
    const eventsLog = document.getElementById("events-log");
    const updateBtn = document.getElementById("update-btn");
    const intervalSelect = document.getElementById("update-interval");
    const campusSelect = document.getElementById("campus-select");

    eventsSidebar.style.display = "none";

    window.addEventListener("load", () => {
      fetchCampuses();
      loadFullMap();
      startAutoUpdate();
      checkSystemStatus();
    });

    async function fetchCampuses() {
      try {
        const token = await getAccessToken();
        const res = await fetch(`${BASE_URL}/campuses`, {
          headers: { Authorization: `Bearer ${token}` },
        });
        if (res.ok) {
          const data = await res.json();
          populateCampusSelect(data.campuses || []);
        }
      } catch (e) {
        console.error("Failed to fetch campuses", e);
      }
    }

    function populateCampusSelect(campusesList) {
      const existingValues = new Set(
        Array.from(campusSelect.options).map((o) => o.value)
      );

      campusesList.forEach((c) => {
        if (!existingValues.has(c.id) && !IGNORED_CAMPUSES.has(c.id)) {
          const opt = document.createElement("option");
          opt.value = c.id;
          let name = c.fullName || c.name;
          if (name.startsWith("–®–∫–æ–ª–∞ 21, ")) {
            name = name.substring(10);
          }
          opt.textContent = name;
          campusSelect.appendChild(opt);
        }
      });
    }

    campusSelect.addEventListener("change", () => {
      const val = campusSelect.value;
      if (!val) return;

      currentCampusId = val;

      clusters = [];
      mapData.clear();
      hostState.clear();

      const loading = mapLoading;
      const preload = document.querySelector(".preload");

      mapView.innerHTML = "";
      mapView.appendChild(loading);

      if (preload) {
        preload.style.display = "flex";
        mapView.appendChild(preload);
      }

      loadFullMap();
    });

    sidebarToggle.addEventListener("click", () => {
      eventsSidebar.classList.toggle("visible");
      sidebarToggle.innerHTML = eventsSidebar.classList.contains("visible")
        ? "‚ñ∂"
        : "‚óÄ";
    });

    let activeTooltip = null;
    let activeSeatElement = null;

    function hideTooltip() {
      seatTooltip.classList.remove("active");
      if (activeSeatElement) {
        activeSeatElement.classList.remove("selected");
        activeSeatElement = null;
      }
    }

    window.addEventListener("scroll", hideTooltip, true);
    mapView.addEventListener("scroll", hideTooltip);

    const UserCache = {
      get: (login) => {
        try {
          const data = localStorage.getItem(`watchman_user_${login}`);
          if (!data) return null;
          const parsed = JSON.parse(data);
          if (Date.now() - parsed.timestamp > 24 * 60 * 60 * 1000)
            return null;
          return parsed;
        } catch (e) {
          return null;
        }
      },
      set: (login, data) => {
        try {
          localStorage.setItem(
            `watchman_user_${login}`,
            JSON.stringify({
              ...data,
              timestamp: Date.now(),
            })
          );
        } catch (e) {
          console.warn("Cache full or error", e);
        }
      },
    };

    document.addEventListener("click", (e) => {
      if (
        !seatTooltip.contains(e.target) &&
        !e.target.classList.contains("seat")
      ) {
        hideTooltip();
      }
    });

    async function fetchClusters(token) {
      let retries = 3;
      while (retries > 0) {
        try {
          const authToken = token || (await getAccessToken());
          const response = await fetch(
            `${BASE_URL}/campuses/${currentCampusId}/clusters`,
            {
              headers: { Authorization: `Bearer ${authToken}` },
            }
          );

          if (!response.ok)
            throw new Error(`HTTP error! status: ${response.status}`);

          const data = await response.json();
          if (data && data.clusters) {
            clusters = data.clusters.sort((a, b) =>
              b.name.localeCompare(a.name)
            );
          } else {
            console.warn("Unexpected clusters format:", data);
            clusters = [];
          }
          return clusters;
        } catch (e) {
          console.warn(`Retry fetchClusters (${retries} left)`, e);
          retries--;
          if (retries === 0) {
            console.error("Error fetching clusters:", e);
            showStatus("Error fetching clusters");
            return [];
          }
          await new Promise((r) =>
            setTimeout(r, 2000 * Math.pow(2, 3 - retries))
          );
        }
      }
    }

    async function fetchClusterMap(clusterId, token) {
      const authToken = token || (await getAccessToken());
      const response = await fetch(`${BASE_URL}/clusters/${clusterId}/map`, {
        headers: { Authorization: `Bearer ${authToken}` },
      });

      if (!response.ok)
        throw new Error(`HTTP error! status: ${response.status}`);

      const data = await response.json();
      return data.clusterMap || [];
    }

    async function loadFullMap(isRefresh = false) {
      if (!isRefresh) {
        mapLoading.style.display = "flex";
        const preload = document.querySelector(".preload");
        if (preload) preload.style.display = "flex";
      }

      try {
        const token = await getAccessToken();

        if (clusters.length === 0) {
          await fetchClusters(token);
        }

        if (clusters.length > 0) {
          const promises = clusters.map(async (cluster) => {
            await new Promise((r) => setTimeout(r, Math.random() * 500));

            let retries = 3;
            while (retries > 0) {
              try {
                const hosts = await fetchClusterMap(cluster.id, token);
                mapData.set(cluster.id, hosts);

                hosts.forEach((host) => {
                  const seatId = `${cluster.id}-${host.row}-${host.number}`;

                  if (host.login) {
                    hostState.set(seatId, {
                      user: host.login,
                      seatId: seatId,
                      location: `${cluster.name} ${host.row}-${host.number}`,
                    });
                  } else {
                    if (hostState.has(seatId)) {
                      hostState.delete(seatId);
                    }
                  }
                });
                break;
              } catch (e) {
                console.warn(
                  `Retry map fetch for ${cluster.name} (${retries} left)`,
                  e
                );
                retries--;
                if (retries === 0)
                  console.error(`Failed to fetch map for ${cluster.name}`);
                await new Promise((r) =>
                  setTimeout(r, 2000 * Math.pow(2, 3 - retries))
                );
              }
            }
          });

          await Promise.all(promises);
        }
        renderMap();
      } catch (e) {
        console.error("Error in loadFullMap:", e);
        showStatus("–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫–≥—Ä—É–∑–∫–µ –∫–∞—Ä—Ç—ã");
      } finally {
        mapLoading.style.display = "none";
      }
    }

    async function preloadTopParticipants() {
      const seats = Array.from(document.querySelectorAll(".seat.occupied"));
      if (seats.length === 0) return;

      for (let i = seats.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [seats[i], seats[j]] = [seats[j], seats[i]];
      }

      const targets = seats.slice(0, 15);

      try {
        const token = await getAccessToken();

        for (const seat of targets) {
          if (window.isInteracting) {
            await new Promise(r => setTimeout(r, 1000));
          }

          const login = seat.dataset.login;
          if (login && !UserCache.get(login)) {
            try {
              const details = await fetchUserDetails(login, token);
              UserCache.set(login, details);
              await new Promise(r => setTimeout(r, 200));
            } catch (e) {
              console.warn("Preload failed for", login);
            }
          }
        }
      } catch (e) {
        console.error("Preload token error");
      }
    }

    function renderMap() {
      const loading = mapLoading;
      const preload = document.querySelector(".preload");

      mapView.innerHTML = "";
      mapView.appendChild(loading);
      if (preload) {
        preload.style.display = "none";
        mapView.appendChild(preload);
      }

      if (clusters.length === 0) {
        const msg = document.createElement("div");
        msg.className = "message-loaded";
        msg.style.position = "relative";
        msg.style.background = "transparent";
        msg.textContent = "–ù–µ—Ç –∫–ª–∞—Å—Ç–µ—Ä–æ–≤ –≤ —ç—Ç–æ–º –∫–∞–º–ø—É—Å–µ";
        mapView.appendChild(msg);
        return;
      }

      const template = CAMPUS_TEMPLATES[currentCampusId];
      let itemsToRender = [];
      const renderedClusterIds = new Set();

      if (template) {
        template.forEach((item) => {
          if (item.type === "html") {
            itemsToRender.push(item);
          } else if (item.type === "cluster") {
            const cluster = clusters.find(
              (c) =>
                (item.id && c.id === item.id) ||
                (item.name && c.name === item.name)
            );
            if (cluster) {
              itemsToRender.push({ ...item, cluster });
              renderedClusterIds.add(cluster.id);
            }
          }
        });
      }

      clusters.forEach((cluster) => {
        if (!renderedClusterIds.has(cluster.id)) {
          itemsToRender.push({ type: "cluster", cluster, align: "left" });
        }
      });

      let currentPair = [];

      itemsToRender.forEach((item) => {
        if (item.type === "html") {
          if (currentPair.length > 0) {
            const cont = document.createElement("div");
            cont.className = "cluster_cont";
            currentPair.forEach((el) => cont.appendChild(el));
            mapView.appendChild(cont);
            currentPair = [];
          }

          const div = document.createElement("div");
          div.innerHTML = item.content;
          mapView.appendChild(div);
          return;
        }

        const cluster = item.cluster;
        const hosts = mapData.get(cluster.id) || [];
        if (hosts.length === 0) return;

        const rowCounts = new Map();
        let isWide = false;
        hosts.forEach((h) =>
          rowCounts.set(h.row, (rowCounts.get(h.row) || 0) + 1)
        );
        for (let count of rowCounts.values()) {
          if (count > 10) {
            isWide = true;
            break;
          }
        }

        const section = document.createElement("div");
        section.className = "cluster-section";

        const title = document.createElement("h3");
        title.className = "cluster-title";
        title.textContent = cluster.name;
        section.appendChild(title);

        const rows = new Map();
        hosts.forEach((host) => {
          const r = host.row;
          if (!rows.has(r)) rows.set(r, []);
          rows.get(r).push(host);
        });

        const sortedRows = Array.from(rows.keys()).sort((a, b) => a - b);

        sortedRows.forEach((r) => {
          const rowDiv = document.createElement("div");
          rowDiv.className = "seat-row";
          if (item.align === "right") {
            rowDiv.classList.add("right");
          }

          const rowHosts = rows.get(r).sort((a, b) => a.number - b.number);

          rowHosts.forEach((host) => {
            const seat = document.createElement("div");
            seat.className = "seat";
            seat.textContent = host.number;

            const location = `${cluster.name} ${host.row}-${host.number}`;
            seat.dataset.location = location;

            if (host.isLocked || host.status === "blocked") {
              seat.classList.add("blocked");
              seat.title = "Blocked";
            }

            if (host.login) {
              seat.classList.add("occupied");
              seat.dataset.login = host.login;
              seat.title = host.login;

              seat.addEventListener("click", (e) =>
                showTooltip(e, host, location)
              );
            }

            rowDiv.appendChild(seat);
          });

          section.appendChild(rowDiv);
        });

        if (isWide) {
          if (currentPair.length > 0) {
            const cont = document.createElement("div");
            cont.className = "cluster_cont";
            currentPair.forEach((el) => cont.appendChild(el));
            mapView.appendChild(cont);
            currentPair = [];
          }
          const cont = document.createElement("div");
          cont.className = "cluster_cont";
          cont.appendChild(section);
          mapView.appendChild(cont);
        } else {
          currentPair.push(section);

          if (currentPair.length === 2) {
            const cont = document.createElement("div");
            cont.className = "cluster_cont";
            currentPair.forEach((el) => cont.appendChild(el));
            mapView.appendChild(cont);
            currentPair = [];
          }
        }
      });

      if (currentPair.length > 0) {
        const cont = document.createElement("div");
        cont.className = "cluster_cont";
        currentPair.forEach((el) => cont.appendChild(el));
        mapView.appendChild(cont);
      }

      preloadTopParticipants();
    }

    async function showTooltip(e, host, location) {
      window.isInteracting = true;
      e.stopPropagation();

      if (activeSeatElement) {
        activeSeatElement.classList.remove("selected");
      }
      activeSeatElement = e.target;
      activeSeatElement.classList.add("selected");

      const rect = e.target.getBoundingClientRect();

      seatTooltip.style.top = `${rect.top + window.scrollY - 150}px`;
      seatTooltip.style.left = `${rect.left + window.scrollX - 120}px`;
      seatTooltip.classList.add("active");

      document.getElementById("tt-location").textContent = location;

      if (host.login) {
        document.getElementById("tt-login").innerHTML =
          '<a href="https://platform.21-school.ru/profile/' +
          host.login +
          '" target="_blank">' +
          host.login +
          "</a>";

        if (window.handleDebugTooltip && window.handleDebugTooltip(host.login)) {
          window.isInteracting = false;
          return;
        }

        const cached = UserCache.get(host.login);
        if (cached) {
          updateTooltipUI(cached);
          window.isInteracting = false;
          return;
        }

        document.getElementById("tt-level").textContent = "–ó–∞–≥—Ä—É–∂–∞–µ–º...";
        document.getElementById("tt-classname").textContent = "...";
        document.getElementById("tt-project").textContent = "–ó–∞–≥—Ä—É–∂–∞–µ–º...";
        document.getElementById("tt-status").textContent = "...";
        document.getElementById("tt-status").style.background = "#eee";

        try {
          const token = await getAccessToken();
          const details = await fetchUserDetails(host.login, token);

          UserCache.set(host.login, details);
          updateTooltipUI(details);
        } catch (err) {
          console.error(err);
        } finally {
          window.isInteracting = false;
        }
      } else {
        window.isInteracting = false;
      }
    }

    function updateTooltipUI(details) {
      document.getElementById("tt-level").textContent =
        "–£—Ä–æ–≤–µ–Ω—å: " + details.level;
      document.getElementById("tt-classname").textContent = details.className;
      document.getElementById("tt-project").textContent = details.project;
      document.getElementById("tt-status").textContent = details.status;
      document.getElementById("tt-status").style.background =
        details.statusColor;
    }

    async function fetchUserDetails(login, token) {
      let level = "-";
      let className = "-";
      let project = "–ù–µ—Ç –ø—Ä–æ–µ–∫—Ç–∞";
      let status = "-";
      let statusColor = "#eee";

      try {
        const basicRes = await fetch(`${BASE_URL}/participants/${login}`, {
          headers: { Authorization: `Bearer ${token}` },
        });

        if (basicRes.ok) {
          const basic = await basicRes.json();
          if (basic.level !== undefined && basic.level !== null)
            level = basic.level;
          if (basic.className) className = basic.className;
          else if (basic.pool_month && basic.pool_year)
            className = `${basic.pool_month} ${basic.pool_year}`;
          if (basic.status) status = basic.status;
        }

        const projRes = await fetch(
          `${BASE_URL}/participants/${login}/projects?limit=1000`,
          {
            headers: { Authorization: `Bearer ${token}` },
          }
        );

        if (projRes.ok) {
          const projBody = await projRes.json();
          const projData = projBody.projects || [];

          const getPriority = (status) => {
            const s = status ? status.toUpperCase() : "";
            if (
              [
                "IN_REVIEWS",
                "REVIEWING",
                "WAITING_FOR_PEER_REVIEW",
                "PEER_REVIEW",
                "CHECKING",
                "WAITING_FOR_CORRECTION",
              ].includes(s)
            )
              return 1;
            if (["IN_PROGRESS"].includes(s))
              return 2;
            if (["REGISTERED", "ASSIGNED"].includes(s))
              return 3;
            if (s === "ACCEPTED") return 4;
            if (s === "FAILED") return 5;
            return 6;
          };

          const getDate = (p) => {
            return new Date(
              p.updatedDateTime ||
              p.createdDateTime ||
              p.completionDateTime ||
              0
            ).getTime();
          };

          projData.sort((a, b) => {
            const prioA = getPriority(a.status);
            const prioB = getPriority(b.status);
            if (prioA !== prioB) return prioA - prioB;
            return getDate(b) - getDate(a);
          });

          if (projData.length > 0) {
            const p = projData[0];
            project = p.title;

            if (p.status) {
              status = p.status
                .toLowerCase()
                .split("_")
                .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                .join(" ");
            } else {
              status = "Unknown";
            }

            const prio = getPriority(p.status);
            if (prio <= 2) statusColor = "#fff3cd";
            else if (prio === 3) statusColor = "#d1e7dd";
            else statusColor = "#f8d7da";
          }
        }

        return { level, className, project, status, statusColor };
      } catch (e) {
        console.error("Fetch Details Critical Fail", e);
        return { level, className, project, status, statusColor };
      }
    }

    fetchCampuses();
    loadFullMap();
    startAutoUpdate();

    function showStatus(msg) {
      const el = document.getElementById("status-message");
      el.textContent = msg;
      el.className = "show";
      setTimeout(() => (el.className = ""), 3000);
    }

    function startAutoUpdate() {
      if (pollTimer) clearInterval(pollTimer);
      if (countdownTimer) clearInterval(countdownTimer);

      const val = intervalSelect.value;
      if (val === "manual") {
        updateBtn.textContent = "–û–±–Ω–æ–≤–∏—Ç—å";
        return;
      }

      const intervalSec = parseInt(val) * 60;
      countdownTimer = startCountdownTimer(intervalSec, (remaining) => {
        updateBtn.textContent = `–û–±–Ω–æ–≤–∏—Ç—å (${formatDurationHMS(remaining)})`;
        if (remaining <= 0) {
          checkUpdates();
          startAutoUpdate();
        }
      }, countdownTimer);
    }

    function updateDropdownText(seconds) {
      const selectedOption = intervalSelect.options[intervalSelect.selectedIndex];
      const baseText = getBaseOptionText(intervalSelect.value);
      if (intervalSelect.value === "manual") {
        selectedOption.text = baseText;
      } else {
        selectedOption.text = `${baseText} (${formatDurationHMS(seconds)})`;
      }
    }

    function getBaseOptionText(value) {
      switch (value) {
        case "manual": return "–í—Ä—É—á–Ω—É—é";
        case "5": return "–ö–∞–∂–¥—ã–µ 5 –º–∏–Ω—É—Ç";
        case "15": return "–ö–∞–∂–¥—ã–µ 15 –º–∏–Ω—É—Ç";
        case "30": return "–ö–∞–∂–¥—ã–µ 30 –º–∏–Ω—É—Ç";
        case "60": return "–ö–∞–∂–¥—ã–π —á–∞—Å";
        default: return "–ò–Ω—Ç–µ—Ä–≤–∞–ª";
      }
    }

    function resetDropdownText() {
      Array.from(intervalSelect.options).forEach(opt => {
        opt.text = getBaseOptionText(opt.value);
      });
    }

    intervalSelect.addEventListener("change", () => {
      startAutoUpdate();
      notifySubscription("–ö–∞–º–ø—É—Å", intervalSelect.value);
    });

    updateBtn.addEventListener("click", async () => {
      updateBtn.classList.add("updating");
      try {
        await checkUpdates();
      } finally {
        updateBtn.classList.remove("updating");
      }
      if (intervalSelect.value !== "manual") {
        startAutoUpdate();
      }
    });

    async function checkUpdates() {
      console.log("Checking for updates...");
      const oldState = new Map(hostState);

      await loadFullMap(true);
      checkSystemStatus();

      const updates = [];
      const now = new Date();
      const timeStr = `${String(now.getHours()).padStart(2, "0")}:${String(
        now.getMinutes()
      ).padStart(2, "0")}`;

      function shouldTrack(user) {
        return !!user;
      }

      hostState.forEach((data, key) => {
        if (!oldState.has(key)) {
          if (shouldTrack(data.user)) {
            updates.push({
              type: "login",
              location: data.location,
              user: data.user,
              time: timeStr,
            });
          }
        } else if (oldState.get(key).user !== data.user) {
          if (shouldTrack(data.user)) {
            updates.push({
              type: "change",
              location: data.location,
              user: data.user,
              time: timeStr,
            });
          }
        }
      });

      oldState.forEach((data, key) => {
        if (!hostState.has(key)) {
          if (shouldTrack(data.user)) {
            updates.push({
              type: "logout",
              location: data.location,
              user: data.user,
              time: timeStr,
            });
          }
        }
      });

      if (updates.length > 0) {
        updates.forEach((update) => logUpdate(update));

        const creds = getStoredCredentials();
        if (creds && creds.tgToken && creds.tgId) {
          const lines = updates.map(u => {
            if (u.type === 'login') return `${u.user} –ø—Ä–∏—à–µ–ª –≤ ${u.location}`;
            if (u.type === 'logout') return `${u.user} —É—à–µ–ª –∏–∑ ${u.location}`;
            return `üîÑ ${u.user} –ø–µ—Ä–µ—Å–µ–ª –Ω–∞ ${u.location}`;
          });
          const msg = `–ß–∞—Å–æ–≤–æ–π / –ö–∞–º–ø—É—Å. –°–æ–±—ã—Ç–∏—è:\n${lines.join('\n')}`;
          sendTelegramMessage(msg.replace(/&rarr;/g, "->"));
        }
      }
    }

    function logUpdate(update) {
      const entry = document.createElement("div");
      entry.className = "log-entry";

      let header = update.user;
      let text = "";
      if (update.type === "login") text = `–ü—Ä–∏—à–µ–ª –≤ ${update.location}`;
      else if (update.type === "logout") text = `–£—à–µ–ª –∏–∑ ${update.location}`;
      else if (update.type === "change") text = `–ü–µ—Ä–µ—Å–µ–ª –Ω–∞ ${update.location}`;

      entry.innerHTML = `
            <div class="log-time">${update.time}</div>
            <div class="log-content">
                <span class="log-header">${header}</span>
                <span class="log-details">${text}</span>
            </div>
        `;
      eventsLog.prepend(entry);

      if (eventsLog.children.length > 0) {
        eventsSidebar.style.display = "flex";
      }
    }

    window.clusters = clusters;
    window.mapData = mapData;
    window.hostState = hostState;
    window.logUpdate = logUpdate;
    window.showStatus = showStatus;
  </script>

  <!--<script src="debug.js"></script>-->
</body>

</html>